# no-c-runtime

This is a minimal template for compiling and linking a C program without the C runtime. In its current form, it is applicable for the combination (Windows OS + MSVC compiler + x86/64 architecture). If some other combination is needed, then the principles described below can be adapted to those situations. The purpose of this template is to serve as a light guide on how to set up things, if the need for excluding C runtime ever arises.

## What does it actully do?

First, we force the compiler to not include default libraries (like C runtime), by providing a flag (*-nodefaultlib* for MSVC). Then, we manually provide the minimal libraries that are needed (only kernel32.lib on Windows).

Now, since there is no C runtime, there is no requirement to provide the *main* function symbol for the linker. *main* function is no longer an entry to the program and instead it is an OS specific function which represents the default entry for the OS executable format. On Windows, that function is *void __stdcall WinMainCRTStartup()*. The purpose of this function is to be used as an entry point for the piece of code that is supposed to initialize the C runtime library. If we don't want to use this function, but instead want to use some random function that we wrote, we need to indicate that to the linker, so that it sets that random function as an entry point. In this repository, we provide our own definition for *WinMainCRTStartup()*, and we don't need to indicate that to the linker, since it will set it as an entry point by default.

Next, we need to set up some flags that control how the stack will be handled. More precisely, they control what kind of code will the compiler generate and automatically inject into our code to ensure the proper stack management.

When we exclude the C runtime, the linker will ask us to provide implementations for functions that handle *stack guarding*. We could try to provide our own definitions, but instead we just instruct the compiler to not use any *stack guarding* functionality. This means that the compiler will not inject the code that writes the magic value to the stack between return address and local function parameters. It will also not inject the code that checks whether this magic value is the same before trying to jump back to return address. The magic number that would otherwise be used is usually generated by the loader when the program is loaded by using the pseudo-random number generator seeded with environmental randomness (random values from system ports, network packet timings etc.). By removing *stack guarding*, we are removing one layer of protection from stack overflow.

If we try to allocate some local space within a function that is larger than some threshold value (usually the standard page size 4KiB), we will run into a linking error. The compiler sees statically that we are making this large stack allocation and it either injects functions or directly emits code that implements the *stack probing* functionality. If we use GCC, there will probably be no problem since it will directly emit instructions, however, if we use MSVC, it will inject a call to *__chkstk* function, which is provided by the runtime and it will cause the linking error. The role of *stack probing* is the following. At any point in time, there is some number of pages that are used by the stack. The OS will also keep the *guard page* as the last page, just after the stack pages, in order to prevent the stack pointer from jumping and writing to/reading from arbitrary memory past the guard page. The problem is that the guard page doesn't protect memory in cases where the function allocates stack memory that is larger than one page, since in that case, we can jump over the guard page and still write some portion of memory that lies past it. We can potentially write even past the size of the whole stack. Stack probes prevent this by breaking down large local allocation to page sized chunks. Instead of moving the stack pointer by the whole size of the locally allocated memory, the compiler will generate the code that will first allocate one page, then touch it, and repeat this process as long as the local memory requires it and as long as we don't go past the stack size. If we do, then the exception is raised. Because this is a minimal template, we don't provide functions needed for *stack probing* on MSVC and instead we turn it off. The guard page is still there and whenever it is touched, the OS will give us a new page for the stack and move the guard page, but we still have a problem if we allocate big local variable/array that goes past the guard page, and we never touch the guard page while working with the given variable/array. This means that we are reading/writing memory that is not paged (or at least memory that shouldn't be accessed), which will probably lead to a crash. To prevent this, we stop relying on the guard page for dynamic stack growth and instead reserve and commit the whole stack at once (in this template, that means 1MiB stack) and take responsibility for never going past that threshold.

At this point, we are able to compile, link and run a simple program (we still can't use copies for example), provided that we are on the x64 architecture. If we are on x86, then there are two additional problems. First one is that the linker will ask us to provide functions like *_ftol2*, *_ltof3* etc. if we are using corresponding float operations (symbols with no implementation are provided for these functions, except in two cases with small implementations to serve as an example). The second problem is that the linker will ask us to provide functions for emulating 64 bit operations on a 32 bit architecture if we use 64 bit types in our code (symbols and their implementation for these functions are taken directly from MSVC assembly files and adapted to be used as part of the C code by using inline assembly).

If everything mentioned above is satisfied, then we can run the program without the C runtime. But, we still can't use all features. For example, if we do anything that might force the compiler to use *memset* or *memcpy*, the linker will give us a missing symbol error. To demontrate futher what to do for such cases, a simple, inefficient implementation for *memset* and *memcpy* is provided (here, both things are presented as functions, not compiler intrinsics, and neither of them use SIMD). We can even go further and try to use things like the *new* C++ operator and see what kind of linking error will that give us, but the concept is the same, and the precise implementation is not needed for this minimal template.
